# 02. 클래스와 객체 (Class & Object)

---

## 1️. 객체 (Object)

### 객체란?

> 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중  
> **자신의 속성을 가지며 식별이 가능한 것**

- 객체 = **속성(Field)** + **동작(Method)** 으로 구성

---

### 객체 지향 언어의 4가지 특징

1. **캡슐화 (Encapsulation)**  
   → 관련된 데이터와 알고리즘(코드)을 하나의 묶음으로 정리
2. **상속 (Inheritance)**  
   → 기존 코드를 재활용하기 위한 기법
3. **다형성 (Polymorphism)**  
   → 객체가 상황에 따라 다른 동작을 하는 것
4. **추상화 (Abstraction)**  
   → 불필요한 정보는 숨기고 중요한 정보만 표현

---

## 2️. 객체와 클래스 (Object & Class)

### 클래스란?

- 자바의 **설계도(Template)** 역할  
- 클래스로부터 만들어진 객체를 **인스턴스 (Instance)** 라고 부름

#### 객체 지향 프로그래밍 단계

> 클래스 설계 → 객체 생성 → 객체 이용

---

## 3️. 객체 생성과 참조 변수

### 클래스로부터 객체 생성

```java
new 클래스이름();
```
### - new 연산자는 메모리 힙(Heap) 영역에 객체를 생성
### - 생성된 객체의 주소(번지)가 반환되어 참조 변수에 저장됨

### 참조 변수를 통해 객체에 접근 가능

### 자바의 메모리 사용 영역
1. 메소드 영역 
2. 힙 영역 
3. 스택 영역

## 4. 객체 생성과 참조 변수

```java
public class ClassName {

    // 필드(Field)
    int fieldName;

    // 생성자(Constructor)
    ClassName() {
        ...
    }

    // 메소드(Method)
    void methodName() {
        ...
    }
}
```

### 구성 요소 설명

| 구성 요소                | 설명                     |
| -------------------- | ---------------------- |
| **필드(Field)**        | 객체의 데이터가 저장되는 곳        |
| **생성자(Constructor)** | 객체 생성 시 초기화 역할 담당      |
| **메소드(Method)**      | 객체의 동작(기능)을 수행하는 실행 블록 |

## 5. 필드 선언과 사용
### 필드 선언

1. 클래스 중괄호 블록 안에서, 생성자와 메소드 밖에서 선언
2. 초기값은 생략 가능 (자동으로 기본값으로 초기화됨)
3. 필드는 지역변수와 달리 값을 지정하지 않아도 자동 초기화

```java
public class Student {
    String name;   // 기본값 null
    int age;       // 기본값 0
}
```

## 필드 사용

### 클래스 내부 → 단순히 필드 이름으로 접근
### 클래스 외부 → 객체 생성 후 참조 변수로 접근

```java
Student s1 = new Student();
s1.name = "홍길동";
System.out.println(s1.name);
```

## 6. 생성자 (Constructor)

### 기본 개념
1. 객체가 생성될 때 자동으로 호출되어 초기화 수행
2. 메소드와 비슷하지만 리턴 타입이 없음
3. 클래스 이름과 동일

```java
Student s1 = new Student(); // Student() → 기본 생성자 호출
```

## 생성자 선언

### 개발자가 직접 생성자를 선언 가능
### 생성자를 명시적으로 작성하면 기본 생성자는 자동 생성되지 않음

```java
public class Student {
    String name;
    int age;

    // 생성자
    Student(String n, int a) {
        name = n;
        age = a;
    }
}
```

### 매개변수 이름이 필드 이름과 같으면 "this.필드명" 구분


## 생성자 오버로딩 (Constructor Overloading)

### 다양한 방법으로 객체를 초기화하기 위해 여러 생성자를 정의
### 매개변수의 개수나 타입이 달라야 함

```java
public class Student {
    String name;
    int age;

    Student() {
        this("이름없음", 0);
    }

    Student(String name) {
        this(name, 0);
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

### this() : 같은 클래스의 다른 생성자를 호출할 때 사용

## 7️. 메소드 (Method)
## 메소드 기본 구조

리턴타입 메소드이름(매개변수) {
    실행코드;
    return 리턴값;
}

## 구성 요소
| 구성 요소  | 설명                     |
| ------ | ---------------------- |
| 리턴 타입  | 메소드가 리턴하는 결과의 타입       |
| 메소드 이름 | 기능이 드러나도록 작명           |
| 매개 변수  | 메소드 실행 시 필요한 데이터를 전달받음 |
| 실행 블록  | 실행할 코드 작성              |

### 매개변수 선언

메소드 실행에 필요한 데이터를 외부에서 전달받음
개수가 명확하지 않은 경우 → 가변 매개변수 사용 가능

```java
void printScore(int... scores) {
    for (int s : scores) {
        System.out.println(s);
    }
}
```

### 리턴 타입

메소드 실행 후 반환되는 값의 타입
반환값이 없으면 void 사용

```java
int add(int a, int b) {
    return a + b;
}

void printHello() {
    System.out.println("Hello");
    return; // 생략 가능
}
```

### 메소드 호출

클래스 내부 → 메소드 이름으로 직접 호출
클래스 외부 → 객체 생성 후 참조 변수로 호출

```java
Student s1 = new Student();
s1.study();
```

### 메소드 오버로딩 (Method Overloading)

같은 이름의 메소드를 여러 개 정의할 수 있음
매개변수의 개수 또는 타입이 달라야 함

```java
void println()
void println(int x)
void println(String x)
void println(double x)
void println(Object x)
```

리턴 타입만 다른 경우는 오버로딩이 아님에 주의!

## 8️. 핵심 키워드 정리
| 구분           | 핵심 키워드                        |
| ------------ | ----------------------------- |
| **객체 & 클래스** | 객체, 클래스, new 연산자, 참조 변수, 인스턴스 |
| **필드**       | 필드 선언과 사용, 자동 초기화             |
| **생성자**      | 기본 생성자, 오버로딩, this(), 객체 초기화  |
| **메소드**      | 선언부, 리턴문, 호출, 오버로딩            |


## ✅ 정리 요약

- 클래스는 객체의 설계도이다.
- 객체는 필드(속성)와 메소드(기능)로 구성된다.
- 생성자는 객체 초기화를 담당한다.
- 메소드는 동작(기능)을 수행하며, 오버로딩을 통해 다양하게 정의할 수 있다.